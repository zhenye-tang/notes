## arm 寻址方式

* 寄存器寻址

  ```asm
  mov r1, r2
  add r1, r2, r3
  ```

* 立即数寻址

  ```asm
  ;立即数以 # 为前缀 0x前置表示该立即数为十六进制，不加前缀默认是十进制
  
  add r1, r1, #1
  mov r1, #0xff
  mov r1, #12
  add r1, r1, #16, 20; r1 = r1 + 立即数 16 循环右移20位
  ```

* 寄存器偏移寻址

  ```asm
  ;寄存器寻址的一种特例
  mov r2, r1, LSL #3; r2 = r1 << 3
  add r3, r2, r1, LSL #3; r3 = r2 + r1 << 3
  ```

* 寄存器间接寻址

  ```asm
  ;主要用来在内存和寄存器之间传输数据，寄存器中保存的是数据在内存中的存储地址，通过这个地址在寄存器和内存之间传输数据。C 语言中的指针操作，在汇编层次其实就是使用寄存器间接寻址实现的。
  
  ldr r1, [r2]; 将寄存器 r2 的值（地址）的数据保存到 r1 寄存器中
  sr2 r1, [r2]; 将 r1 的值，写到 r2 寄存器保存的地址下
  ```

* 基址寻址

  ```asm
  ;基址寻址其实也属于寄存器间接寻址。基址寻址将寄存器中的地址与一个偏移量相加，生成一个新地址，然后基于这个新地址去访问内存
  
  ldr r1, [fp, #2]; 将 fp 中的值 + 2 作为新地址，取地址上的值保存到 r1
  ldr r1, [fp,#2]!; fp = fp + 2,然后将 fp 指定的内存单元数据保存到 r1 中
  ```

* 多寄存器寻址

  ```asm
  LDMIA SP!, {r0-r2, r14}; 将内存栈中的数据依次弹出到 r14、r2、r1、r0
  STMDB SP!, {r0-r2, r14}; 将R0、R1、R2、R14 依次压入栈
  LDMFD SP!, {r0-r2, r14}; 将内存栈中的数据依次弹出到r14、r2、r1、r0
  STMFD SP!, {r0-r2, r14}; 将r0、r1、r2、r14 依次压入栈
  ```

* 相对寻址

  ```asm
  ;相对寻址也属于基址寻址，相对顾名思义得有个相对的对象，这个相对的对象就是 pc,以 pc 的值为相对值，然后基于 pc 加上偏移就是新的地址，arm 中的 b、bl、adr 指令其实都是采用相对寻址
  ...
  b loop
  
  loop mov r0, #1
  	 mov r1, r0
  ....
  
  b loop 这条指令等价于 add pc, pc, #offset
  
  #offset 为 b loop 这条指令的地址于标号 loop 地址之间的差。
  b 指令的前后跳转范围为 [0,32MB],如果你编写的程序生成的二进制文件小于32Mb,基本上就可以随意地使用 b 指令跳转。
  除此之外，很多与位置无关地代码，如动态链接共享库，其在汇编代码层次的实现其实也是采用相对寻址的。程序中使用相对寻址访问的好处是不需要重定位，将代码加载到内存中的任何地址都可以直接运行。
  ```

## arm 伪指令

​	arm 伪指令并不是 arm 指令集中定义的标准指令，而是为了编程方便，各家编译器厂商自定义的一些辅助指令。在程序编译时，这些伪指令会被翻译为一条或多条 arm 标准指令。常见的arm伪指令主要有4个：adr、adrl、ldr、nop。nop 指令比较简单，其实就是让 cpu 执行一条空指令达到延时的目的。

* ldr 伪指令与加载指令 ldr 不是一回事。arm 属于 RISC 架构，不能对内存中的数据直接操作，arm 通常会使用 ldr/str 这对加载/存储指令，先将内存中的数据加载到寄存器，然后才能对寄存器中的数据进行操作，最后把寄存器中的处理结果存储到内存中。ldr 伪指令的主要用途是将一个 32 位的内存地址保存到寄存器中。

* 当我们往寄存器传递的地址是一个 32 位的常数时，为什么不能使用 mov，而要使用 ldr 伪指令呢？这需要从 arm 指令的编码格式说起。在一个32位系统中，一条指令通常是32位的，指令中包括操作码和操作数，指令中的操作码和操作数共享32位的存储空间：一般前面的操作码要占据几个比特位，剩下来的留给操作数的编码空间就小于32位了。当编译器遇到 mov r0, #0x24000200 这条指令时，因为后面的操作数是32位，编译器就无法对这条指令进行编码了。为了解决这个问题，编译器提供了一个ldr 伪指令来完成上面的功能

  ```asm
  ldr r0, =0x24000200
  ```

* 上述示例代码中，ldr 不是普通的arm加载指令，而是一个伪指令，为了与arm指令集中的加载指令ldr区别开，ldr伪指令中的操作数前会有一个等号=，用于表示这是一个伪指令。

* 因为伪指令并不是 arm 指令集中定义的标准指令，所以 cpu 硬件译码电路并不支持直接运行这些伪指令，在程序编译期间，这些伪指令会被标准的arm指令替代。编译器在处理伪指令时，根据伪指令中的操作数大小，使用不同的arm标准指令替代。比如当 ldr 伪指令中的操作数小于 8 位时，ldr 伪指令一般会被 mov 指令替代。下面两条汇编指令是等价的

  ```asm
  ldr r0, =200
  mov r0, #200
  ```

* 当 ldr 伪指令中的操作数大于8位时，ldr 伪指令会被编译器转换为 ldr 标准指令 + 文字池的形式。

  ```asm
  ldr r0, = 0x24000200 ;伪指令
  
  ldr ro, [pc, #offset] ;翻译成的标准指令
  ...
  ...
  ...
  dcd 0x24000200; 文字池
  ```

  编译器会首先在内存中分配一个四字节大小的存储单元，然后将这个32位的地址0x0x24000200放到该存储单元中，该存储单元通常也叫做文字池（literal pool）。紧接着编译器计算出该存储单元到 ldr 伪指令之间的偏移 offset，然后使用寄存器相对寻址，就可以将这个32位的立即数送到 r0 寄存器中。偏移量 offset 的大小一般要小于 4kb，所以在分析汇编代码时，存放这些32位地址常量的文字池一般紧挨着当前指令的代码段，直接放置到当前代码段的后面（验证过，确实如此）。