## 有符号与无符号

* 无符号减去无符号，当减数大于被减数时，是无符号

  ```c
  unsigned int a = 1;
  
  /* 错误的做法 */
  if(0 < a - sizeof(a)) // 32位机，此时 a - sizeof(a) 本来是 -3 ,但是会被编译器默认转为无符号数 0xffff fffd
  {
      printf("yes!!");
  }
  else
  {
      printf("NoNo!!");
  }
  /* 正确的做法 */
  if(0 < (int)(a - sizeof(a)))
  {
      printf("yes!!");
  }
  else
  {
      printf("NoNo!!");
  }
  
  ```

* 负数在内存中的存储方式：原码的补码。有符号数最高 bit 位为符号位（1为负数，0为整数）。计算机内部采用2的补码（Two's Complement）表示负数

* 2 的补码本质

  * 对于负数，可以表示为 0 - A = -A
  * 如 0 - 5：
    * 0000 0000
    * 0000 0101
    * —————
    * 不够减，0 借 1，相当于
    * 1 0000 0000
    *    0000 0101
    * ————————
    * 相当于 (1111 1111 + 1) - (0000 0101)
    * 11111010 + 1 = 1111 1011

  * 对于 -5 在内存中的存放方式
  * 抛出补码、源码、反码的概念
    * 源码：正数的源码为原始二进制，负数的源码为最高bit为1的原始二进制
    * 反码：正数的反码与源码相同。负数的反码：最高 bit 位不变，其余 bit 取反
    * 补码：正数的补码与源码相同。负数的补码：反码 + 1（与 2 的补码本质），相当于 0 - 正数，0 不够 借1，等价于 （11111111 + 1）- 正数
  * 先获得 -5 的源码：10000000  00000000  00000000 0101
  * 然后 -5 的反码：11111111 11111111 11111111 1010
  * 反码 +1 ：0xffffffb

## 指针相加减

* 指向同一对象的指针相加：增加一个对象的大小，而不是单纯的地址加1

* 指向同一对象的指针相减：计算两个指针之间的对象个数

  ```c
  int test_arry[10] = {0};
  printf("%d\n",&test_arry[6] - &test_arry[0]);// 输出6
  int *p = &test_arry[0];
  p++; // p = &test_arry[1];
  // 要计算两个地址之间的字节差距                                                                               
  int size = (uint8_t)&test_arry[6] - (uint8_t)&test_arry[0]; // 等于 24
  ```

  