## 链接、装载与库

### 1. 操作系统做什么

​	提供抽象的接口，管理硬件资源。不能让 CPU 闲下来，操作系统能够充分的利用起 CPU，而不是跑裸机代码（直接让 cpu 运行代码，没有调度过程，依靠中断与大循环执行任务）。可以强制剥夺CPU资源并且分配给它认为目前最需要的进程，如果操作系统给每个进程的时间都很短，即 CPU 在多个进程间快速地切换，从而造成了多进程同时运行的假象。

​	操作系统作为硬件层的上层，是对硬件的管理和抽象。繁琐的硬件细节都交给了操作系统，具体应该是交给了操作系统中的硬件驱动程序来完成。驱动程序可以看作是操作系统的一部分，它往往跟操作系统内核运行在特权级，但是又与操作系统内核之间有一定的独立性，使得驱动程序有比较好的灵活性。操作系统开发者为每个硬件厂商提供了一系列接口和框架，凡是按照这个接口和框架开发的驱动程序都可以在该操作系统上使用。

### 2. 内存不够怎么办？

​	进程的总体目标是希望每个进程从逻辑上来看都可以独占计算机的资源。操作系统的多任务功能使得CPU能够在多个进程间很好的共享，从进程的角度看好像是独占了CPU而不用考虑其他进程分享CPU的事情。操作系统的I/O抽象模型也很好地实现了IOs=设备的共享和抽象，唯一声响的就是主存，也就是内存的分配问题。

* 隔离：虚拟地址空间，每个进程都有自己的独立的虚拟空间，而且每个进程只能访问自己的地址空间，这样就有效地做到了进程的隔离
* 分段：把一段程序所需要的内存空间大小的虚拟空间映射到某个地址空间。虚拟空间中的每个字节相对于物理空间中的每个字节。对于程序来说，无论它们被分配到物理地址的哪一个区域，对于程序来说都是透明的，他们不需要关心物理地址地变化，它们只需要按照从0x0地址来编写程序、放置变量，所以程序不再需要重定位。这样地机制依然存在问题，分段内存区域地映射还是按照程序为党委，如果内存不足，被换入换出到磁盘的都是整个程序，这样势必会造成大量的磁盘访问操作，从而严重影响速度。
* 分页：需要使用一个硬件 MMU（Menory Management Unit）d地部件进行页映射，在页映射模式下，CPU 发出的是 Virtual Address，程序看到的是虚拟地址，经过 MMU 转换后就变成了物理地址。

### 3. 编译和链接

#### 3.1 被隐藏的过程

* 预编译

  * gcc -E hello.c -o hello.i

  * 将所有的 #define 删除，并且展开所有的宏定义
  * 处理所有条件预编译指令，如 #if、#ifdef 等
  * 处理 #include 预编译指令，将被包含的文件插入到该预编译指令的位置。递归进行，被依赖的的文件可能还依赖其他文件
  * 删除所有注释
  * 保留所有的 #pragma 编译器指令，因为编译器需要使用它们

* 编译

  * gcc -S hello.i -o hello.s

  * 把预处理完的文件进行词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件（涉及到编译原理的一些内容）

* 汇编

  * gcc -c hello.s -o hello.o

  * 将汇编代码转换成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。根据汇编指令和机器指令的对照表一一翻译，可以调用汇编器 as hello.s -o hello.o，或者 gcc -c hello.c -o hello.o ，一次性通过预编译、编译、汇编生成目标文件（Object File）

* 链接

  * 链接器 LD 来完成这一重大使命
  * 需要将一堆的文件链接起来才可以得到可执行文件 a.out
  * 定义在其他模块的全局变量和函数在最终运行时的绝对地址都要在最终的链接的时候才能确定。

综上现代编译器可以将一个源代码文件编译成一个未链接的目标文件，然后由链接器最终将这些目标文件链接起来，形成可执行文件。

#### 3.2 静态链接基础概念

​	连接过程包括了`地址` 和 `空间分配`、符号决议、重定位这些步骤。无非就是把一些指令对其他符号地址的引用加以修正

​	如：在 main.c 模块中调用 foo 函数时必须要确切知道 foo 这个函数的地址，但是由于每个模块都是单独编译的，在编译器编译 main.c 的时候他并不知道 foo 函数的地址，所以它暂时把这些调用 foo 的指令的 目标地址搁置，等待最后链接的时候由链接器去将这些指令的目标地址修正。如果没有链接器，必须要手动的把每个调用 foo 的指令进行修正，并填入正确的 foo 函数地址。

​	这个地址修正的过程也被叫做 重定位（Relocation），每个要被修正的地方叫一个重定位入口（Relocation Entry）。

#### 3. 3 目标文件里有什么

##### 3.3.1 目标文件格式

​	目标文件就是源代码编译后未进行链接的那些中间文件，它跟可执行文件的内容与结构很相似，所以跟可执行文件格式一起采用一种格式存储。

​	静态链接库稍有不同，它是把很多目标文件捆绑在一起形成一个文件，再加上些索引，可以简单理解为一个包含很多目标文件的文件包。elf 文件标准里把系统中采用 elf 格式的文件归为4类

* 可重定位文件：编译器生成的目标文件
* 可执行文件：elf、exe
* 共享目标文件：Linux 的 .so 、win 的 dll
* 核心转储文件：linux 下程序存在异常时输出的文件，core dump

